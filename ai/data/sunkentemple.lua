t_dungeons[109] = {
	-- Line 1: From entrance RHS stair to Mijan's floor
	{
		{-323.675, 99.8938, -131.85, -1000, 2}, -- 1
		{-363.688, 115.881, -131.856, -1000, 2}, -- 2
		{-369.911, 132.237, -131.859, -1000, 2}, -- 3
		{-396.118, 148.587, -131.857, -1000, 2}, -- 4
		{-388.766, 159.971, -128.894, -1000, 2}, -- 5
		{-379.645, 173.956, -128.768, -1000, 2}, -- 6
		{-353.391, 164.291, -109.064, -1000, 2}, -- 7
		{-343.349, 155.308, -109.065, -1000, 2}, -- 8
		{-354.662, 147.337, -108.724, -1000, 2}, -- 9
		{-380.466, 158.54, -89.2272, -1000, 2}, -- 10
		{-389.903, 162.667, -89.2301, -1000, 2}, -- 11
		{-379.708, 173.819, -89.2317, -1000, 2}, -- 12
		{-353.471, 164.12, -69.4879, -1000, 2}, -- 13
	},
	-- Line 2: From Mijan's floor to ring hall
	{
		{-350.932, 163.413, -69.4878, -1000, 2}, -- 1
		{-335.349, 145.103, -69.4878, -1000, 2}, -- 2
		{-341.254, 133.626, -69.4878, -1000, 2}, -- 3
		{-356.383, 115.589, -54.0561, -1000, 2}, -- 4
	},
	-- Line 3: From Mijan's floor to Mijan
	{
		{-365.83, 142.625, -69.4878, -1000, 2}, -- 1
		{-363.549, 127.919, -69.4878, -1000, 2}, -- 2
		{-383.008, 123.335, -69.4878, -1000, 2}, -- 3
		{-391.829, 125.876, -65.4636, -1000, 2}, -- 4
		{-410.906, 131.811, -66.9137, -1000, 2}, -- 5
	},
	-- Line 4: Ring hall Mijan entrance towards Hukku entrance
	{
		{-356.683, 112.738, -54.0598, -1000, 2}, -- 1
		{-370.485, 109.356, -53.9463, -1000, 2}, -- 2
		{-379.376, 51.4057, -53.9458, -1000, 2}, -- 3
	},
	-- Line 5: From entrance LHS stair to Hukku's floor
	{
		{-323.964, 97.2962, -131.848, -1000, 2}, -- 1
		{-370.238, 88.846, -131.848, -1000, 2}, -- 2
		{-372.87, 69.5727, -131.863, -1000, 2}, -- 3
		{-368.826, 65.9482, -128.667, -1000, 2}, -- 4
		{-354.223, 60.7566, -128.776, -1000, 2}, -- 5
		{-349.557, 31.1539, -108.968, -1000, 2}, -- 6
		{-356.601, 16.9634, -108.969, -1000, 2}, -- 7
		{-363.799, 25.1935, -108.775, -1000, 2}, -- 8
		{-368.021, 52.4225, -89.1296, -1000, 2}, -- 9
		{-365.876, 64.6009, -89.1366, -1000, 2}, -- 10
		{-354.771, 59.9921, -89.1368, -1000, 2}, -- 11
		{-350.454, 32.6415, -69.3923, -1000, 2}, -- 12
	},
	-- Line 6: From Hukku's floor to ring hall
	{
		{-348.096, 28.6157, -69.3923, -1000, 2}, -- 1
		{-370.908, 5.29748, -69.3923, -1000, 2}, -- 2
		{-393.435, 8.41713, -53.884, -1000, 2}, -- 3
	},
	-- Line 7: From Hukku's floor to Hukku
	{
		{-364.284, 21.1414, -69.3923, -1000, 2}, -- 1
		{-375.878, 30.3931, -69.3923, -1000, 2}, -- 2
		{-386.335, 23.6177, -69.3923, -1000, 2}, -- 3
		{-401.537, 38.2763, -69.3923, -1000, 2}, -- 4
		{-403.288, 45.9461, -65.1467, -1000, 2}, -- 5
		{-406.027, 71.3314, -65.6898, -1000, 2}, -- 6
	},
	-- Line 8: Ring hall Hukku entrance towards Mijan entrance
	{
		{-394.452, 6.59159, -53.9034, -1000, 2}, -- 1
		{-407.43, 21.0065, -53.9458, -1000, 2}, -- 2
		{-382.726, 45.6428, -53.9458, -1000, 2}, -- 3
	},
	-- Line 9: Ring hall Hukku entrance towards Gasher entrance
	{
		{-393.063, 10.9046, -53.8484, -1000, 2}, -- 1
		{-412.25, 14.2378, -53.9463, -1000, 2}, -- 2
		{-463.897, -4.40175, -53.9463, -1000, 2}, -- 3
		{-516.87, 10.0458, -53.9463, -1000, 2}, -- 4
		{-551.943, 47.6313, -53.9463, -1000, 2}, -- 5
		{-566.48, 77.3925, -53.9463, -1000, 2}, -- 6
		{-576.854, 80.2653, -53.9453, -1000, 2}, -- 7
	},
	-- Line 10: From Refuse to Gasher's floor
	{
		{-587.038, 55.2403, -148.714, -1000, 2}, -- 1
		{-579.302, 43.0081, -148.598, -1000, 2}, -- 2
		{-554.341, 31.3426, -128.757, -1000, 2}, -- 3
		{-546.127, 23.4981, -128.764, -1000, 2}, -- 4
		{-555.249, 15.0834, -128.765, -1000, 2}, -- 5
		{-581.334, 25.8102, -108.938, -1000, 2}, -- 6
		{-589.37, 36.1544, -108.933, -1000, 2}, -- 7
		{-580.335, 41.7989, -108.928, -1000, 2}, -- 8
		{-554.449, 30.6975, -89.0909, -1000, 2}, -- 9
		{-546.901, 20.959, -89.0986, -1000, 2}, -- 10
		{-556.006, 14.8282, -89.0972, -1000, 2}, -- 11
		{-581.516, 25.7798, -69.3528, -1000, 2}, -- 12
	},
	-- Line 11: From Gasher's floor to ring hall
	{
		{-583.106, 26.3522, -69.3528, -1000, 2}, -- 1
		{-598.39, 50.2461, -69.3528, -1000, 2}, -- 2
		{-592.911, 57.8871, -69.3528, -1000, 2}, -- 3
		{-579.72, 73.6473, -55.5377, -1000, 2}, -- 4
	},
	-- Line 12: From Gasher's floor to Gasher
	{
		{-568.753, 46.8401, -69.3528, -1000, 2}, -- 1
		{-571.312, 62.7027, -69.3528, -1000, 2}, -- 2
		{-550.44, 65.1458, -69.3528, -1000, 2}, -- 3
		{-541.733, 64.4255, -65.3467, -1000, 2}, -- 4
		{-516.748, 53.3293, -65.3269, -1000, 2}, -- 5
	},
	-- Line 13: Ring hall Gasher entrance towards Zolo entrance
	{
		{-574.765, 73.0995, -53.946, -1000, 2}, -- 1
		{-563.624, 92.9678, -53.946, -1000, 2}, -- 2
		{-554.707, 130.51, -53.946, -1000, 2}, -- 3
	},
	-- Line 14: From Refuse to Zolo's floor
	{
		{-561.516, 179.135, -148.757, -1000, 2}, -- 1
		{-566.898, 166.126, -148.648, -1000, 2}, -- 2
		{-564.715, 138.462, -128.815, -1000, 2}, -- 3
		{-570.52, 125.489, -128.812, -1000, 2}, -- 4
		{-580.273, 131.6, -128.776, -1000, 2}, -- 5
		{-584.062, 159.328, -108.977, -1000, 2}, -- 6
		{-579.258, 171.775, -108.982, -1000, 2}, -- 7
		{-569.126, 166.594, -108.977, -1000, 2}, -- 8
		{-565.921, 138.343, -89.1406, -1000, 2}, -- 9
		{-570.535, 126.096, -89.1457, -1000, 2}, -- 10
		{-579.907, 131.675, -89.1343, -1000, 2}, -- 11
		{-583.865, 159.439, -69.4014, -1000, 2}, -- 12
	},
	-- Line 15: From Zolo's floor to ring hall
	{
		{-583.894, 160.74, -69.4014, -1000, 2}, -- 1
		{-576.324, 181.902, -69.4014, -1000, 2}, -- 2
		{-561.728, 186.468, -69.4013, -1000, 2}, -- 3
		{-540.111, 183.035, -54.196, -1000, 2}, -- 4
	},
	-- Line 16: From Zolo's floor to Zolo
	{
		{-557.425, 160.496, -69.4014, -1000, 2}, -- 1
		{-545.457, 165.332, -69.4014, -1000, 2}, -- 2
		{-532.936, 152.925, -69.4014, -1000, 2}, -- 3
		{-530.875, 144.875, -65.3657, -1000, 2}, -- 4
		{-530.097, 118.685, -65.4663, -1000, 2}, -- 5
	},
	-- Line 17: Ring hall Zolo entrance towards Gasher entrance
	{
		{-534.948, 184.264, -53.9698, -1000, 2}, -- 1
		{-532.1, 163.684, -54.0946, -1000, 2}, -- 2
		{-552.914, 136.479, -53.9463, -1000, 2}, -- 3
	},
	-- Line 18: Ring hall Zolo entrance towards Mijan entrance
	{
		{-539.56, 177.849, -53.9755, -1000, 2}, -- 1
		{-522.926, 175.29, -54.0954, -1000, 2}, -- 2
		{-466.609, 193.786, -53.9463, -1000, 2}, -- 3
		{-412.423, 175.805, -53.9463, -1000, 2}, -- 4
		{-379.52, 138.387, -53.9463, -1000, 2}, -- 5
		{-372.824, 118.464, -53.9463, -1000, 2}, -- 6
		{-355.858, 108.947, -54.0597, -1000, 2}, -- 7
	},
	-- Line 19: Ring hall Zu'Lor entrance to Zu'Lor
	{
		{-425.609, 162.294, -53.884, -1000, 2}, -- 1
		{-450.569, 176.064, -65.3502, -1000, 2}, -- 2
		{-478.524, 159.308, -65.4823, -1000, 2}, -- 3
	},
	-- Line 20: Ring hall Loro entrance to Loro
	{
		{-507.357, 28.6628, -53.8762, -1000, 2}, -- 1
		{-483.559, 14.3554, -65.345, -1000, 2}, -- 2
		{-455.643, 30.2798, -65.3165, -1000, 2}, -- 3
	},
	-- Line 21: From entrance rhs stair to Hall of Serpents
	{
		{-369.279, 52.4756, -128.797, -1000, 2}, -- 1
		{-365.663, 24.5983, -148.64, -1000, 2}, -- 2
		{-371.444, 13.5282, -148.758, -1000, 2}, -- 3
	},
	-- Line 22: From entrance lhs stair to Hall of Serpents
	{
		{-380.866, 157.767, -128.893, -1000, 2}, -- 1
		{-353.957, 147.127, -148.738, -1000, 2}, -- 2
		{-349.016, 135.933, -148.868, -1000, 2}, -- 3
	},
	-- Line 23: Hall of Serpents lhs entrance stair to rhs entrance stair
	{
		{-357.951, 135.523, -148.937, -1000, 2}, -- 1
		{-375.818, 122.152, -148.803, -1000, 2}, -- 2
		{-371.108, 87.9118, -148.803, -1000, 2}, -- 3
	},
	-- Line 24: Hall of Serpents rhs entrance stair to lhs entrance stair
	{
		{-381.634, 16.6322, -148.842, -1000, 2}, -- 1
		{-392.071, 36.6535, -148.802, -1000, 2}, -- 2
		{-379.539, 50.9197, -148.802, -1000, 2}, -- 3
		{-373.583, 77.6042, -148.802, -1000, 2}, -- 4
	},
	-- Line 25: Hall of Serpents rhs entrance stair to rhs ring hall stair
	{
		{-377.055, 22.6023, -148.832, -1000, 2}, -- 1
		{-399.829, 27.9629, -148.802, -1000, 2}, -- 2
		{-423.213, 8.17608, -148.802, -1000, 2}, -- 3
		{-468.896, -2.51203, -148.802, -1000, 2}, -- 4
		{-518.641, 11.8214, -148.802, -1000, 2}, -- 5
		{-549.504, 45.9752, -148.802, -1000, 2}, -- 6
		{-570.329, 63.2832, -148.802, -1000, 2}, -- 7
	},
	-- Line 26: Hall of Serpents lhs entrance stair to lhs ring hall stair
	{
		{-358.657, 127.278, -148.871, -1000, 2}, -- 1
		{-379.716, 131.346, -148.803, -1000, 2}, -- 2
		{-400.218, 165.216, -148.803, -1000, 2}, -- 3
		{-420.063, 181.398, -148.805, -1000, 2}, -- 4
		{-470.914, 193.261, -148.803, -1000, 2}, -- 5
		{-513.919, 180.741, -148.803, -1000, 2}, -- 6
		{-533.306, 163.222, -148.716, -1000, 2}, -- 7
		{-556.184, 167.138, -148.842, -1000, 2}, -- 8
	},
	-- Line 27: Hall of Serpents lhs ring hall stair to rhs ring hall stair
	{
		{-550.712, 174.118, -148.85, -1000, 2}, -- 1
		{-546.381, 153.126, -148.745, -1000, 2}, -- 2
		{-562.547, 112.013, -148.802, -1000, 2}, -- 3
	},
	-- Line 28: Hall of Serpents rhs ring hall stair to lhs ring hall stair
	{
		{-570.133, 56.1042, -148.801, -1000, 2}, -- 1
		{-560.654, 71.0495, -148.801, -1000, 2}, -- 2
		{-564.192, 102.757, -148.801, -1000, 2}, -- 3
	},
	-- Line 29: Hall of Serpents statue 4
	{
		{-516.815, 28.1968, -148.801, -1000, 2}, -- 1
		{-526.922, 41.9479, -148.801, -1000, 2}, -- 2
		{-520.546, 47.584, -148.801, -1000, 2}, -- 3
		{-491.893, 47.2742, -148.744, -1000, 2}, -- 4
	},
	-- Line 30: Hall of Serpents statue 6
	{
		{-435.348, 20.3582, -148.591, -1000, 2}, -- 1
		{-450.39, 17.4759, -148.599, -1000, 2}, -- 2
		{-452.091, 27.166, -148.599, -1000, 2}, -- 3
		{-436.98, 55.0597, -148.742, -1000, 2}, -- 4
	},
	-- Line 31: Hall of Serpents statue 2
	{
		{-384.013, 85.9255, -148.653, -1000, 2}, -- 1
		{-393.557, 70.4776, -148.841, -1000, 2}, -- 2
		{-399.928, 73.8542, -148.841, -1000, 2}, -- 3
		{-418.619, 101.59, -148.742, -1000, 2}, -- 4
	},
	-- Line 32: Hall of Serpents statue 5
	{
		{-418.226, 163.698, -148.802, -1000, 2}, -- 1
		{-408.932, 145.352, -148.803, -1000, 2}, -- 2
		{-447.287, 140.123, -148.742, -1000, 2}, -- 3
	},
	-- Line 33: Hall of Serpents statue 3
	{
		{-500.826, 170.034, -148.802, -1000, 2}, -- 1
		{-481.72, 173.804, -148.802, -1000, 2}, -- 2
		{-493.361, 140.486, -148.743, -1000, 2}, -- 3
	},
	-- Line 34: Hall of Serpents statue 1
	{
		{-549.971, 103.954, -148.805, -1000, 2}, -- 1
		{-541.193, 121.752, -148.805, -1000, 2}, -- 2
		{-520.643, 96.7675, -148.744, -1000, 2}, -- 3
	},
	-- Line 35: Million paths through Hakkars arena
	{
		{-343.545, 94.3273, -90.9275, -1000, 2}, -- 1
		{-409.237, 86.3263, -91.2016, -1000, 2}, -- 2
		{-420.421, 78.0694, -91.4353, -1000, 2}, -- 3
		{-459.32, 60.5902, -91.4004, -1000, 2}, -- 4
		{-498.168, 39.3935, -91.0383, -1000, 2}, -- 5
	},
	-- Line 36
	{
		{-343.64, 93.196, -90.9281, -1000, 2}, -- 1
		{-407.459, 85.7184, -91.1543, -1000, 2}, -- 2
		{-429.457, 42.2564, -91.0201, -1000, 2}, -- 3
		{-421, 15.1196, -90.8589, -1000, 2}, -- 4
	},
	-- Line 37
	{
		{-343.21, 95.3927, -90.9282, -1000, 2}, -- 1
		{-426.967, 94.0485, -90.9843, -1000, 2}, -- 2
		{-462.554, 83.2928, -94.5796, -1000, 2}, -- 3
		{-509.402, 87.9759, -90.8071, -1000, 2}, -- 4
		{-656.144, 90.7457, -90.8331, -1000, 2}, -- 5
		{-659.873, -45.9636, -90.8357, -1000, 2}, -- 6
	},
	-- Line 38
	{
		{-342.966, 96.318, -90.9284, -1000, 2}, -- 1
		{-422.019, 103.376, -90.6885, -1000, 2}, -- 2
		{-480.889, 129.039, -91.283, -1000, 2}, -- 3
		{-501.963, 157.553, -90.8767, -1000, 2}, -- 4
	},
	-- Line 39
	{
		{-342.986, 97.0533, -90.9272, -1000, 2}, -- 1
		{-408.241, 103.567, -91.1873, -1000, 2}, -- 2
		{-436.414, 142.519, -91.241, -1000, 2}, -- 3
		{-392.745, 223.328, -90.8752, -1000, 2}, -- 4
		{-386.992, 271.853, -90.8296, -1000, 2}, -- 5
		{-449.9, 289.07, -90.6194, -1000, 2}, -- 6
		{-490.219, 285.403, -90.7559, -1000, 2}, -- 7
		{-549.13, 270.341, -90.828, -1000, 2}, -- 8
		{-519.804, 191.394, -90.9059, -1000, 2}, -- 9
	},
	-- Line 40
	{
		{-342.956, 95.4155, -90.9283, -1000, 2}, -- 1
		{-425.941, 100.083, -90.9052, -1000, 2}, -- 2
		{-467.376, 110.654, -94.4125, -1000, 2}, -- 3
		{-508.793, 103.734, -90.854, -1000, 2}, -- 4
		{-536.076, 105.178, -90.9026, -1000, 2}, -- 5
	},
	-- Line 41: To Prophet
	{
		{-500.948, 33.0593, -90.8554, -1000, 2}, -- 1
		{-559.14, -68.9824, -90.8418, -1000, 2}, -- 2
		{-489.866, -85.9096, -90.828, -1000, 2}, -- 3
		{-440.357, -82.5668, -90.8274, -1000, 2}, -- 4
		{-428.624, -81.1711, -88.224, -1000, 2}, -- 5
	},
	-- Line 42: Spiral staircase up
	{
		{-332.116, 74.3401, -131.858, -1000, 2}, -- 1
		{-331.184, 40.7323, -130.535, -1000, 2}, -- 2
		{-319.17, 28.3172, -126.028, -1000, 2}, -- 3
		{-297.746, 34.5417, -120.746, -1000, 2}, -- 4
		{-298.704, 60.0702, -114.843, -1000, 2}, -- 5
		{-320.471, 65.9139, -109.482, -1000, 2}, -- 6
		{-332.732, 47.2731, -104.415, -1000, 2}, -- 7
		{-319.059, 28.8123, -98.7068, -1000, 2}, -- 8
		{-296.829, 36.8311, -93.0493, -1000, 2}, -- 9
		{-295.113, 45.6372, -90.8401, -1000, 2}, -- 10
		{-296.567, 94.6041, -91.4671, -1000, 2}, -- 11
		{-330.902, 95.24, -90.9287, -1000, 2}, -- 12
	},
	-- Line 43: Pit of refuse paths
	{
		{-337.403, 94.6025, -172.98, -1000, 2}, -- 1
		{-417.303, 90.5724, -173.428, -1000, 2}, -- 2
		{-424.808, 67.2518, -173.535, -1000, 2}, -- 3
		{-446.036, 49.0041, -173.425, -1000, 2}, -- 4
		{-473.502, 43.5617, -173.487, -1000, 2}, -- 5
		{-494.549, 51.6152, -173.366, -1000, 2}, -- 6
		{-514.855, 71.7484, -173.335, -1000, 2}, -- 7
		{-518.122, 93.3568, -173.402, -1000, 2}, -- 8
	},
	-- Line 44
	{
		{-336.46, 97.9259, -172.969, -1000, 2}, -- 1
		{-417.704, 100.192, -173.494, -1000, 2}, -- 2
		{-422.336, 122.022, -173.25, -1000, 2}, -- 3
		{-447.749, 141.383, -173.42, -1000, 2}, -- 4
		{-479.45, 145.346, -173.522, -1000, 2}, -- 5
		{-511.859, 120.993, -173.448, -1000, 2}, -- 6
		{-517.498, 98.7655, -173.501, -1000, 2}, -- 7
	},
	-- Line 45
	{
		{-337.752, 96.1871, -172.977, -1000, 2}, -- 1
		{-411.11, 94.9869, -172.938, -1000, 2}, -- 2
		{-421.312, 99.4819, -174.093, -1000, 2}, -- 3
		{-447.596, 95.049, -189.475, -1000, 2}, -- 4
		{-479.67, 107.719, -189.73, -1000, 2}, -- 5
		{-506.678, 93.3629, -189.73, -1000, 2}, -- 6
	},
	-- Line 46
	{
		{-423.731, 89.7222, -174.882, -1000, 2}, -- 1
		{-450.506, 87.322, -189.73, -1000, 2}, -- 2
		{-466.872, 59.6942, -189.73, -1000, 2}, -- 3
		{-496.322, 66.2549, -189.73, -1000, 2}, -- 4
		{-507.044, 85.173, -189.73, -1000, 2}, -- 5
	},
	-- Line 47
	{
		{-451.039, 100.765, -189.73, -1000, 2}, -- 1
		{-446.566, 127.479, -189.73, -1000, 2}, -- 2
		{-480.011, 134.13, -189.73, -1000, 2}, -- 3
		{-508.328, 99.2709, -189.73, -1000, 2}, -- 4
	},
	-- Line 48: Spiral staircase down
	{
		{-330.582, 95.4219, -172.969, -1000, 2}, -- 1
		{-295.911, 96.3613, -173.002, -1000, 2}, -- 2
		{-293.56, 142.805, -172.597, -1000, 2}, -- 3
		{-308.288, 162.342, -166.779, -1000, 2}, -- 4
		{-329.303, 154.192, -161.532, -1000, 2}, -- 5
		{-324.993, 126.808, -155.139, -1000, 2}, -- 6
		{-300.276, 126.664, -149.379, -1000, 2}, -- 7
		{-295.781, 152.496, -142.981, -1000, 2}, -- 8
		{-319.846, 162.39, -136.941, -1000, 2}, -- 9
		{-331.018, 143.599, -131.863, -1000, 2}, -- 10
		{-331.94, 125.254, -131.85, -1000, 2}, -- 11
	},
};

local SunkenTemple = t_dungeons[109];
SunkenTemple.Ghosts = {
	Id  = 8317, -- Atal'ai Deathwalker's Spirit
	Id2 = 8505, -- Hex of Jammal'an
};

local STRK_ROLE = "SunkenTemple.Ghosts.OldRole";

-- remember everyone's roles
function SunkenTemple.Ghosts:PreprocessAgents(data)
	for i,ai in ipairs(data.agents) do
		local data = ai:GetData();
		if (nil == data[STRK_ROLE]) then
			data[STRK_ROLE] = ai:GetRole();
		end
	end
end

-- reset everyone's roles
function SunkenTemple.Ghosts:RestoreAgents(data)
	for i,ai in ipairs(data.agents) do
		local data = ai:GetData();
		if (data[STRK_ROLE]) then
			local agent = ai:GetPlayer();
			agent:ClearMotion();
			Command_ClearAll(ai, "SunkenTemple.Ghosts.RestoreAgents");
			ai:SetRole(data[STRK_ROLE]);
			data[STRK_ROLE] = nil;
		end
	end
end

function SunkenTemple.Ghosts:TakeAgent(ai)
	if (nil == ai:GetData()[STRK_ROLE]) then
		error("SunkenTemple.Ghosts.TakeAgent: " .. ai:GetPlayer():GetName() .. " - has no saved role, agent will not function correctly");
	end
	Command_ClearAll(ai, "SunkenTemple.Ghosts taking control");
	ai:SetRole(ROLE_SCRIPT);
	ai:GetPlayer():ClearMotion();
end

function SunkenTemple.Ghosts:GetRealRole(ai)
	local data = ai:GetData();
	if (nil == data["SunkenTemple.Ghosts.OldRole"]) then
		error("SunkenTemple.Ghosts.GetRealRole: " .. ai:GetPlayer():GetName() .. " - has no saved role, agent will not function correctly");
	end
	return data["SunkenTemple.Ghosts.OldRole"];
end

function SunkenTemple.Ghosts:RestoreAgent(ai)
	local data = ai:GetData();
	if (data[STRK_ROLE]) then
		ai:SetRole(data[STRK_ROLE]);
		ai:GetPlayer():ClearMotion();
		Command_ClearAll(ai, "SunkenTemple.Ghosts releasing control");
		return;
	end
	error("SunkenTemple.Ghosts.RestoreAgent: " .. ai:GetPlayer():GetName() .. " - has no saved role, agent will not function correctly");
end

function SunkenTemple.Ghosts.Test(hive, data)
	
	local entry  = SunkenTemple.Ghosts.Id;  -- Atal'ai Deathwalker's Spirit
	local entry2 = SunkenTemple.Ghosts.Id2; -- Hex of Jammal'an
	local entries = {[entry] = true, [entry2] = true};
	local targets = data.attackers;
	
	for i = 1, #targets do
		
		local target = targets[i];
		if (entries[target:GetEntry()]) then
			return true;
		end
		
	end
	
	return false;
	
end

function SunkenTemple.Ghosts:OnBegin(hive, data)
	self:PreprocessAgents(data);
end

local function SunkenTemple_AvoidEnemy(self, entries, hive, data)
	local targets = data.attackers;
	
	-- fetch the ghosts and remove them from attack table
	local ghosts = {};
	for i = #targets, 1, -1 do
		
		local target = targets[i];
		if (entries[target:GetEntry()]) then
			table.remove(targets, i);
			table.insert(ghosts, target);
		end
		
	end
	
	-- find which ghost is attacking which agent
	local agentsAttacked = {};
	for i = 1, #ghosts do
		local victim = ghosts[i]:GetVictim();
		if (victim:IsAgent()) then
			agentsAttacked[victim:GetGuid():GetId()] = ghosts[i];
		end
	end
	
	-- flee or reset
	for i = 1, #data.agents do
		
		local ai = data.agents[i];
		local agent = ai:GetPlayer();
		local ghost = agentsAttacked[agent:GetGuid():GetId()];
		
		if (ghost) then
		
			if (agent:GetRole() ~= ROLE_SCRIPT) then
				self:TakeAgent(ai);
			end
			
			if (agent:GetMotionType() ~= MOTION_FOLLOW) then
				agent:MoveFollow(ghost, 7, 0);
			end
			
		elseif (agent:GetRole() == ROLE_SCRIPT) then
			self:RestoreAgent(ai);
		end
		
	end
end

function SunkenTemple.Ghosts:Update(hive, data)
	local entry  = SunkenTemple.Ghosts.Id;  -- Atal'ai Deathwalker's Spirit
	local entry2 = SunkenTemple.Ghosts.Id2; -- Hex of Jammal'an
	local entries = {[entry] = true, [entry2] = true};
	SunkenTemple_AvoidEnemy(self, entries, hive, data);
end

function SunkenTemple.Ghosts:OnEnd(hive, data)
	self:RestoreAgents(data);
end

SunkenTemple.Prophet = {
	Spellid = 12479, -- hex of jammal'an: "You are being transformed..."
	SpellidActive = 12480, -- hex of jammal'an transformed
	TankGotHex = false,
};

function SunkenTemple.Prophet:OnBegin(hive, data)
	SunkenTemple.Ghosts:PreprocessAgents(data);
end

function SunkenTemple.Prophet:MoveAway(ai, agent, posLeft, posRight)
	
	-- todo: this check should only be ran if not moving
	local pos = posLeft;
	if (posRight and agent:GetDistance(posRight[1], posRight[2], posRight[3]) > agent:GetDistance(posLeft[1], posLeft[2], posLeft[3])) then
		pos = posRight;
	end
	
	if (agent:GetRole() ~= ROLE_SCRIPT) then
		SunkenTemple.Ghosts:TakeAgent(ai);
	end
	
	local x,y,z = pos[1], pos[2], pos[3];
	if (agent:GetDistance(x,y,z) > 2) then
	
		-- move away
		if (false == ai:IsMovingTo(x,y,z)) then
			agent:ClearMotion();
			agent:MovePoint(x,y,z,false);
			Print("SunkenTemple.Prophet: moving away", agent:GetName(), "far =", posRight ~= nil);
		end
	
	else
		
		-- wait
		if (agent:GetMotionType() ~= MOTION_IDLE) then
			agent:ClearMotion();
			Print("SunkenTemple.Prophet: waiting", agent:GetName(), "far =", posRight ~= nil);
		end
		
	end
	
end

local function can_cc_players(ai, agent)
	if (ai:GetRole() == ROLE_TANK or ai:GetRole() == ROLE_HEALER) then
		return false;
	end
	local class = agent:GetClass();
	if (class == CLASS_MAGE) then
		return true;
	end
	return false;
end

function SunkenTemple.Prophet:Update(hive, data)
	
	local posLeft  = {-492.452, -50.285, -90.827};
	local posRight = {-500.492, -113.544, -90.827};
	local pos      = {-440.674, -53.793, -90.827};
	
	local cc, ccAI;
	-- find mage
	for i = 1, #data.agents do
		
		local ai = data.agents[i];
		local agent = ai:GetPlayer();
		if (can_cc_players(ai, agent)) then
			ccAI, cc = ai, agent;
			break;
		end
		
	end
	
	local isCcActive = cc and cc:HasAura(self.SpellidActive);
	
	-- move far away from group
	for i = 1, #data.agents do
		
		local ai = data.agents[i];
		local agent = ai:GetPlayer();
		local isPending = agent:HasAura(self.Spellid);
		local isActive  = agent:HasAura(self.SpellidActive);
		local isAny     = isPending or isActive;
		local isTank    = SunkenTemple.Ghosts:GetRealRole(ai) == ROLE_TANK;
		local isCc      = agent == cc;
		
		if (isPending) then
			
			if (false == (isTank or isCc)) then
				
				local function do_hot()
					
					if (SunkenTemple.Ghosts:GetRealRole(ai) == ROLE_HEALER) then
						if (agent:GetRole() ~= ROLE_SCRIPT) then
							agent:InterruptSpell(CURRENT_GENERIC_SPELL);
							SunkenTemple.Ghosts:TakeAgent(ai);
						end
						local aidata = ai:GetData();
						if (aidata.hot) then
							for i = 1, #data.agents do
								local allyAI, ally = data.agents[i], data.agents[i]:GetPlayer();
								if (allyAI:CmdType() == CMD_TANK) then
									if (false == ally:HasAura(aidata.hot) and agent:CastSpell(ally, aidata.hot, false) == CAST_OK) then
										Print("SunkenTemple.Prophet: healer hot on", ally:GetName(), "by", agent:GetName());
										return 2;
									end
									return ally:HasAura(aidata.hot) and 2 or 1;
								end
							end
						end
					end
					return 0;
					
				end
				
				-- non tanks move over to Cc highlight spot
				-- but if cc agent is not available we run far away
				if (not isCcActive) then
					if (agent:GetAuraTimeLeft(self.Spellid) < 4000) then
						self:MoveAway(ai, agent, pos);
					elseif (agent:GetAuraTimeLeft(self.Spellid) < 6000) then
						do_hot();
					end
				else
					local hotresult = do_hot();
					if (hotresult == 2 or hotresult == 0) then
						self:MoveAway(ai, agent, posLeft, posRight);
					end
				end
				
			elseif (isCc) then
				
				-- assume no one is there to cc the cc agent, run far away. No wait
				self:MoveAway(ai, agent, posLeft, posRight);
			
			else
				
				if (ai:GetRole() ~= ROLE_SCRIPT) then
					SunkenTemple.Ghosts:TakeAgent(ai);
				end
				
				-- tanks need to drop tank command early, otherwise same as non cc
				if (agent:GetAuraTimeLeft(self.Spellid) < 4000) then
					if (ai:CmdType() ~= CMD_NONE) then
						Command_ClearAll(ai, "SunkenTemple.Prophet is moving tank");
					end
					self:MoveAway(ai, agent, pos);
				else
					
					-- drop tanking
					if (ai:CmdType() ~= CMD_ENGAGE) then
						Print("SunkenTemple.Prophet: tank to drop tanking", agent:GetName(), agent:GetAuraTimeLeft(self.Spellid));
						Command_IssueEngage(ai, hive);
					end
					
				end
				
			end
			
		elseif (isActive) then
			
			-- mark for cc
			if (not isCc) then
				table.insert(data.forcedCc, agent);
			end
			
		else
		
			if (ai:GetRole() == ROLE_SCRIPT) then
				SunkenTemple.Ghosts:RestoreAgent(ai);
			end
			
		end
		
	end
	
	-----------------------------------------------------------
	-- Old no cc code
	-----------------------------------------------------------
	
	-- local posLeft  = {-492.452, -50.285, -90.827};
	-- local posRight = {-500.492, -113.544, -90.827};
	
	-- local tankChosen;
	
	-- -- determine if tank's possessed
	-- for i = 1, #data.agents do
		
		-- local ai = data.agents[i];
		-- local agent = ai:GetPlayer();
		-- if ((agent:HasAura(self.Spellid) or agent:HasAura(self.SpellidActive)) and ai:GetRole() == ROLE_TANK) then
			-- if (ai:CmdType() == CMD_TANK or self.TankGotHex) then
				-- tankChosen = agent;
				-- self.TankGotHex = true;
				-- break;
			-- end
		-- end
	-- end
	
	-- if (not tankChosen) then self.TankGotHex = false; end
	
	-- -- move far away from group
	-- for i = 1, #data.agents do
		
		-- local ai = data.agents[i];
		-- local agent = ai:GetPlayer();
		-- if (not tankChosen) then
			
			-- -- just the affected character moves away
			-- if (agent:HasAura(self.Spellid)) then
				-- self:MoveAway(ai, agent, posLeft, posRight);
			-- elseif (ai:GetRole() == ROLE_SCRIPT) then
				-- SunkenTemple.Ghosts:RestoreAgent(ai);
			-- end
			-- SunkenTemple.encounters[3].rchrpos = {x = -449.815, y = -86.634, z = -90.827, melee = "ignore"};
		
		-- else
			
			-- -- everyone moves except tank when time is low
			-- if (ai:CmdType() ~= CMD_TANK and tankChosen:GetAuraTimeLeft(self.Spellid) < 3000) then
				-- local pos = posLeft;
				-- if (tankChosen:GetDistance(posRight[1], posRight[2], posRight[3]) > tankChosen:GetDistance(posLeft[1], posLeft[2], posLeft[3])) then
					-- pos = posRight;
				-- end
				-- -- self:MoveAway(ai, agent, posLeft, posRight);
				-- SunkenTemple.encounters[3].rchrpos = {x = pos[1], y = pos[2], z = pos[3]};
			-- elseif (ai:GetRole() == ROLE_TANK and agent ~= tankChosen and tankChosen:GetAuraTimeLeft(self.Spellid) < 3000) then
				-- self:MoveAway(ai, agent, posLeft, posRight);
			-- end
			
		-- end
		
	-- end
	
end

function SunkenTemple.Prophet:OnEnd(hive, data)
	SunkenTemple.Ghosts:RestoreAgents(data);
end

SunkenTemple.Hakkar = {
	FlameId1      = 148418, -- Eternal Flame; 47561;
	FlameId2      = 148419, -- Eternal Flame
	FlameId3      = 148420, -- Eternal Flame
	FlameId4      = 148421, -- Eternal Flame
	BloodkeeperId = 8438,   -- Source of Hakkari Blood
	HakkariBlood  = 10460,  -- Used to extinguish Eternal Flames and unlock Avatar of Hakkar
};

function SunkenTemple.Hakkar.Test(hive, data)

	local owner = data.owner;
	-- if true then return true end
	-- out of combat and non free for all loot modes only
	if (not owner or owner:GetLootMode() == 0) then
		return false;
	end
	
	local pos = {x = -467.997, y = 273.191, z = -90.452};
	local r = 110.0;
	
	if (owner:GetDistance(pos.x, pos.y, pos.z) > r) then
		return false;
	end
	
	local bloodkeeper = GetUnitsWithEntryNear(owner, SunkenTemple.Hakkar.BloodkeeperId, pos.x, pos.y, pos.z, 30.0, false, true)[1];
	if (bloodkeeper) then
		return true;
	end
	
	for i,ai in ipairs(data.agents) do
		local agent = ai:GetPlayer();
		if (agent:HasItemCount(SunkenTemple.Hakkar.HakkariBlood, 1)) then
			return true;
		end
	end
	
	return false;
	
end

function SunkenTemple.Hakkar:OnBegin(hive, data)
	SunkenTemple.Ghosts:PreprocessAgents(data);
end

function SunkenTemple.Hakkar:Update(hive, data)
	
	local owner = data.owner or data.agents[1];
	if (not owner or #data.attackers > 1) then
		return;
	end
	
	do
		-- local flames = table_merge(
			-- GetObjectsWithEntryAround(owner, self.FlameId1, 50, true),
			-- GetObjectsWithEntryAround(owner, self.FlameId2, 50, true),
			-- GetObjectsWithEntryAround(owner, self.FlameId3, 50, true),
			-- GetObjectsWithEntryAround(owner, self.FlameId4, 50, true)
		-- );
		-- for j = 1, #flames do
			-- Print(GetObjectGOState(owner, flames[j]));
		-- end
		-- local ox,oy,oz = owner:GetPosition();
		-- Print(owner:HasItemCount(SunkenTemple.Hakkar.HakkariBlood, 1));
		-- local bloodkeepers = GetUnitsWithEntryNear(owner, SunkenTemple.Hakkar.BloodkeeperId, ox, oy, oz, 30.0, false, true);
		-- for i,candidate in ipairs(bloodkeepers) do
			-- if (candidate:IsDead()) then
				-- local loot = candidate:GetLootList();
				-- Debug_PrintTable(loot);
			-- end
		-- end
	end
	
	-- deposit first
	for i,ai in ipairs(data.agents) do
		local agent = ai:GetPlayer();
		-- Print(agent:GetName(), "blood count 1 =", agent:HasItemCount(SunkenTemple.Hakkar.HakkariBlood, 1));
		if (agent:HasItemCount(self.HakkariBlood, 1)) then
			
			local goal = ai:GetTopGoal();
			if (goal:GetSubGoalNum() == 0) then
				
				local flames = table_merge(
					GetObjectsWithEntryAround(owner, self.FlameId1, 30, true),
					GetObjectsWithEntryAround(owner, self.FlameId2, 30, true),
					GetObjectsWithEntryAround(owner, self.FlameId3, 30, true),
					GetObjectsWithEntryAround(owner, self.FlameId4, 30, true)
				);
				
				local flame;
				for j = 1, #flames do
					if (GetObjectGOState(agent, flames[j]) == 1) then
						flame = flames[j];
					end
				end
				
				if (flame) then
					-- send to deposit
					if (ai:GetRole() ~= ROLE_SCRIPT) then
						Print("SunkenTemple.Hakkar: sending to douse", agent:GetName());
						SunkenTemple.Ghosts:TakeAgent(ai);
					end
					goal:AddSubGoal(GOAL_COMMON_UseItemObj, 10, flame, self.HakkariBlood, 0);
				end
			end
			return;
			
		elseif (ai:GetRole() == ROLE_SCRIPT) then
			SunkenTemple.Ghosts:RestoreAgent(ai);
		end
	end

	local ox,oy,oz = owner:GetPosition();
	local bloodkeepers = GetUnitsWithEntryNear(owner, self.BloodkeeperId, ox, oy, oz, 30.0, false, true);
	
	local bloodkeeper;
	local looterAI, looter;
	-- dead bloodkeepers with hakkari blood in loot that any agent is recipient for
	for i,candidate in ipairs(bloodkeepers) do
		if (candidate:IsDead()) then
			for j,ai in ipairs(data.agents) do
				local agent = ai:GetPlayer();
				if (agent:GetGuid() == candidate:GetLootRecipient()) then
					local loot = candidate:GetLootList();
					-- Debug_PrintTable(loot);
					if (table_ifind(loot, self.HakkariBlood) > 0) then
						bloodkeeper = candidate;
						looterAI, looter = ai, agent;
						break;
					end
				end
			end
		end
	end
	
	if (bloodkeeper) then
		
		-- send to loot
		if (looterAI:GetRole() ~= ROLE_SCRIPT) then
			Print("SunkenTemple.Hakkar: sending to loot", looter:GetName());
			SunkenTemple.Ghosts:TakeAgent(looterAI);
		end
		
		-- pretend like we need to be close
		if (looter:GetDistance(bloodkeeper) > 2) then
			local x,y,z = bloodkeeper:GetPosition();
			if (false == looterAI:IsMovingTo(x,y,z)) then
				looter:ClearMotion();
				looter:MovePoint(x,y,z,false);
			end
		else
			
			-- loot
			if (looter:IsMoving()) then
				looter:ClearMotion();
			end
			looter:LootCorpse(bloodkeeper, self.HakkariBlood);
			SunkenTemple.Ghosts:RestoreAgent(looterAI);
			Print("SunkenTemple.Hakkar: finish loot", looter:GetName());
			
		end
		
	end
	
end

function SunkenTemple.Hakkar:OnEnd(hive, data)
	SunkenTemple.Ghosts:RestoreAgents(data);
end

t_dungeons[109].encounters = {
	{name = "Ghosts", script = SunkenTemple.Ghosts, test = SunkenTemple.Ghosts.Test},
	{name = "Atal'alrion"},
	{
		name            = "Jammal'an the Prophet",
		script          = SunkenTemple.Prophet,
		tpos            = {-434.821, -85.926, -89.587},
		rchrpos         = {x = -449.815, y = -86.634, z = -90.827, melee = "ignore"},
		healmax         = true,
		tankswap        = true,
		useForcedCc     = true,
		interruptFilter = function(ai, agent, party, target, targets, threatCheck, maxInterruptDist)
			return target:IsCastingHeal();
		end,
	},
	{
		name = "Shade of Eranikus",
		tankswap = true,
		rchrpos = {x = -661.175, y = -0.810, z = -90.836, melee = "ignore"},
		tpos = {-660.166, -39.655, -90.836},
	},
	{name = "Eternal Flame", script = SunkenTemple.Hakkar, test = SunkenTemple.Hakkar.Test},
	{name = "Avatar of Hakkar"},
};
